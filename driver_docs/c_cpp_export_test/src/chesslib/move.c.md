<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

The `move.c` file in the `c_cpp_export_test` codebase implements functions for handling chess moves, including creating moves, comparing them, and converting between moves and UCI strings.

# Purpose
This C source code file is part of a chess-related software library, specifically handling the representation and manipulation of chess moves. The file provides functions to create, compare, and convert chess moves to and from the Universal Chess Interface (UCI) format. The primary functions include [`moveSq`](#moveSq), which creates a move without promotion, and [`movePromote`](#movePromote), which allows for the specification of a promotion piece type. The [`moveEq`](#moveEq) function checks for equality between two moves, while [`moveGetUci`](#moveGetUci) and [`moveFromUci`](#moveFromUci) handle the conversion of moves to and from UCI strings, respectively. The code is designed to be part of a larger chess library, as indicated by the inclusion of "chesslib/move.h", and it does not define a standalone executable but rather provides utility functions for use in other parts of the chess software.

The file's functionality is narrowly focused on the manipulation of chess moves, with a common theme of facilitating the conversion between internal move representations and the UCI format, which is a standard for communicating chess moves in software. The code includes memory allocation for UCI strings and assumes the presence of other functions and types, such as `sqEq`, `sqGetStr`, and `pieceTypeGetLetter`, which are likely defined elsewhere in the chess library. The lack of error checking in [`moveFromUci`](#moveFromUci) suggests that this function assumes valid input, which is typical in lower-level utility functions where performance is prioritized over robustness. Overall, this file is a specialized component of a chess software library, providing essential move-related operations.
# Imports and Dependencies

---
- `stdio.h`
- `stdlib.h`
- `ctype.h`
- `chesslib/move.h`


# Functions

---
### moveSq<!-- {{#callable:moveSq}} -->
The `moveSq` function creates a move from one square to another without any promotion in a chess game.
- **Inputs**:
    - `from`: The starting square of the move.
    - `to`: The destination square of the move.
- **Control Flow**:
    - The function calls [`movePromote`](#movePromote) with the `from` and `to` squares and `ptEmpty` as the promotion type.
    - The [`movePromote`](#movePromote) function constructs a `move` structure with the given squares and promotion type.
    - The constructed `move` is returned.
- **Output**: A `move` structure representing a move from the `from` square to the `to` square with no promotion.
- **Functions called**:
    - [`movePromote`](#movePromote)


---
### movePromote<!-- {{#callable:movePromote}} -->
The `movePromote` function creates and returns a `move` structure initialized with the given starting square, destination square, and promotion piece type.
- **Inputs**:
    - `from`: The starting square of the move, represented by the type `sq`.
    - `to`: The destination square of the move, represented by the type `sq`.
    - `promotion`: The type of piece to promote to, represented by the type `pieceType`.
- **Control Flow**:
    - A `move` structure `m` is declared.
    - The `from` field of `m` is set to the input `from`.
    - The `to` field of `m` is set to the input `to`.
    - The `promotion` field of `m` is set to the input `promotion`.
    - The function returns the `move` structure `m`.
- **Output**: A `move` structure initialized with the specified `from`, `to`, and `promotion` values.


---
### moveEq<!-- {{#callable:moveEq}} -->
The `moveEq` function checks if two chess moves are equivalent by comparing their starting and ending squares and promotion type.
- **Inputs**:
    - `m1`: The first move to compare, represented as a `move` structure.
    - `m2`: The second move to compare, represented as a `move` structure.
- **Control Flow**:
    - The function calls [`sqEq`](square.c.md#sqEq) to compare the `from` squares of `m1` and `m2`.
    - It then calls [`sqEq`](square.c.md#sqEq) to compare the `to` squares of `m1` and `m2`.
    - Finally, it checks if the `promotion` fields of `m1` and `m2` are equal.
    - The function returns the logical AND of these three comparisons.
- **Output**: A `uint8_t` value that is non-zero (true) if the moves are equivalent, and zero (false) otherwise.
- **Functions called**:
    - [`sqEq`](square.c.md#sqEq)


---
### moveGetUci<!-- {{#callable:moveGetUci}} -->
The `moveGetUci` function generates a UCI (Universal Chess Interface) string representation of a given chess move, including promotion if applicable.
- **Inputs**:
    - `m`: A `move` structure containing the source square, destination square, and optional promotion piece type.
- **Control Flow**:
    - Initialize a character array `p` to store the promotion piece letter, if any.
    - Check if the move includes a promotion; if so, convert the promotion piece type to a lowercase letter and store it in `p[0]`, then allocate memory for a 6-character string.
    - If there is no promotion, allocate memory for a 5-character string.
    - Use `sprintf` to format the move's source square, destination square, and promotion piece (if any) into the allocated string.
    - Return the formatted UCI string.
- **Output**: A dynamically allocated string representing the UCI format of the move, which must be freed by the caller.
- **Functions called**:
    - [`pieceTypeGetLetter`](piece.c.md#pieceTypeGetLetter)
    - [`sqGetStr`](square.c.md#sqGetStr)


---
### moveFromUci<!-- {{#callable:moveFromUci}} -->
The `moveFromUci` function converts a UCI (Universal Chess Interface) string into a `move` structure, representing a chess move with optional promotion.
- **Inputs**:
    - `uci`: A string representing a chess move in UCI format, typically consisting of four characters for the starting and ending squares, and optionally a fifth character for promotion.
- **Control Flow**:
    - Extracts the first two characters from the `uci` string to form the `from` square and the next two characters to form the `to` square.
    - Initializes a `promotion` variable of type `pieceType` to determine if the move includes a promotion.
    - Uses a `switch` statement to check the fifth character of the `uci` string to set the `promotion` type, defaulting to `ptEmpty` if no valid promotion character is found.
    - Creates a `move` structure `m`, setting its `from` and `to` fields using the [`sqS`](square.c.md#sqS) function to convert the `from` and `to` strings into square representations.
    - Sets the `promotion` field of the `move` structure `m` to the determined `promotion` type.
    - Returns the constructed `move` structure `m`.
- **Output**: A `move` structure representing the chess move described by the UCI string, including the starting and ending squares and any promotion.
- **Functions called**:
    - [`sqS`](square.c.md#sqS)



---
Made with ❤️ by [Driver](https://www.driver.ai/)