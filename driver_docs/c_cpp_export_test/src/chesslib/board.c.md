<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

The `board.c` file in the `c_cpp_export_test` codebase implements a chess board, including functions for creating a board from a FEN string, generating legal moves, checking for check and checkmate, and converting the board state back to a FEN string.

# Purpose
This C source code file implements a chess board management system, providing functionality to create, manipulate, and evaluate chess board states. The code is designed to handle chess positions using the Forsyth-Edwards Notation (FEN), which is a standard notation for describing a particular board position of a chess game. The file includes functions to initialize a board from a FEN string, generate legal moves, check for check conditions, and determine if a position has insufficient material to continue the game. It also provides utilities to play moves on the board, check for board equality, and convert a board state back into a FEN string.

The code is structured around a `board` data structure, which encapsulates the state of a chess game, including piece positions, castling rights, en passant targets, and move counters. Key functions include [`boardCreateFromFen`](#boardCreateFromFen) for initializing a board from a FEN string, [`boardGenerateMoves`](#boardGenerateMoves) for generating all legal moves for the current player, and [`boardIsPlayerInCheck`](#boardIsPlayerInCheck) for determining if a player is in check. The file also includes error handling for invalid FEN strings and ensures that moves are only played if they are legal. This code is part of a larger chess library, as indicated by the inclusion of headers like "chesslib/board.h" and "chesslib/piecemoves.h", and is intended to be used as a backend component for chess applications, providing essential board state management and move generation capabilities.
# Imports and Dependencies

---
- `stdio.h`
- `ctype.h`
- `stdlib.h`
- `string.h`
- `chesslib/board.h`
- `chesslib/piecemoves.h`


# Functions

---
### boardCreate<!-- {{#callable:boardCreate}} -->
The `boardCreate` function initializes a new chess board using the standard initial position in FEN notation.
- **Inputs**: None
- **Control Flow**:
    - The function calls [`boardCreateFromFen`](#boardCreateFromFen) with `INITIAL_FEN` as the argument, which represents the standard initial position of a chess game.
    - The function returns the result of [`boardCreateFromFen`](#boardCreateFromFen), which is a pointer to a newly created `board` structure initialized with the initial chess position.
- **Output**: A pointer to a `board` structure initialized with the standard initial chess position, or `NULL` if initialization fails.
- **Functions called**:
    - [`boardCreateFromFen`](#boardCreateFromFen)


---
### boardCreateFromFen<!-- {{#callable:boardCreateFromFen}} -->
The `boardCreateFromFen` function allocates memory for a new chess board and initializes it using a FEN string, returning the board if successful or NULL if initialization fails.
- **Inputs**:
    - `fen`: A string representing the board position in Forsyth-Edwards Notation (FEN).
- **Control Flow**:
    - Allocate memory for a new `board` structure.
    - Call [`boardInitFromFenInPlace`](#boardInitFromFenInPlace) to initialize the board with the given FEN string.
    - If initialization fails (returns non-zero), free the allocated memory and return NULL.
    - If initialization succeeds, return the pointer to the newly created board.
- **Output**: A pointer to a `board` structure initialized with the FEN string, or NULL if initialization fails.
- **Functions called**:
    - [`boardInitFromFenInPlace`](#boardInitFromFenInPlace)


---
### boardInitInPlace<!-- {{#callable:boardInitInPlace}} -->
The `boardInitInPlace` function initializes a chess board to the standard starting position using the FEN string for the initial setup.
- **Inputs**:
    - `b`: A pointer to a `board` structure that will be initialized to the standard starting position.
- **Control Flow**:
    - The function calls [`boardInitFromFenInPlace`](#boardInitFromFenInPlace) with the board pointer `b` and the constant `INITIAL_FEN` which represents the standard starting position in FEN notation.
- **Output**: The function does not return a value; it modifies the board in place to represent the initial chess position.
- **Functions called**:
    - [`boardInitFromFenInPlace`](#boardInitFromFenInPlace)


---
### boardInitFromFenInPlace<!-- {{#callable:boardInitFromFenInPlace}} -->
The function `boardInitFromFenInPlace` initializes a chess board structure from a given FEN (Forsyth-Edwards Notation) string, setting up the board pieces, current player, castling rights, en passant target, and move counters.
- **Inputs**:
    - `b`: A pointer to a `board` structure that will be initialized based on the FEN string.
    - `fen`: A constant character pointer representing the FEN string that describes the board state to be initialized.
- **Control Flow**:
    - Initialize the starting square to the top-left of the board (file 1, rank 8).
    - Iterate over the FEN string to set up the board pieces, handling numbers for empty squares, slashes for rank changes, and specific characters for different pieces.
    - Check for errors such as misplaced slashes, unknown characters, or premature end of the FEN string, returning an error code if any are found.
    - After setting up pieces, read the current player's turn from the FEN string and validate it.
    - Parse the castling rights from the FEN string, updating the board's castling state accordingly.
    - Read the en passant target square from the FEN string, validating and setting it on the board.
    - Parse the half-move clock and full move number from the FEN string using `sscanf`.
    - Return 0 to indicate successful initialization, or 1 if any errors were encountered.
- **Output**: Returns a `uint8_t` value, 0 if the board was successfully initialized from the FEN string, or 1 if an error occurred during parsing.
- **Functions called**:
    - [`sqI`](square.c.md#sqI)
    - [`boardSetPiece`](#boardSetPiece)
    - [`boardGetPiece`](#boardGetPiece)
    - [`sqS`](square.c.md#sqS)


---
### boardSetPiece<!-- {{#callable:boardSetPiece}} -->
The `boardSetPiece` function sets a specific piece on a given square of a chess board.
- **Inputs**:
    - `b`: A pointer to the `board` structure where the piece is to be set.
    - `s`: The square (`sq` type) on the board where the piece should be placed.
    - `p`: The piece (`piece` type) to be placed on the specified square.
- **Control Flow**:
    - Calculate the index of the square `s` using the [`sqGetIndex`](square.c.md#sqGetIndex) function.
    - Set the piece `p` at the calculated index in the `pieces` array of the board `b`.
- **Output**: The function does not return a value; it modifies the board in place by setting the specified piece at the given square.
- **Functions called**:
    - [`sqGetIndex`](square.c.md#sqGetIndex)


---
### boardGetPiece<!-- {{#callable:boardGetPiece}} -->
The `boardGetPiece` function retrieves the chess piece located at a specified square on a given chess board.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the chess board from which the piece is to be retrieved.
    - `s`: A `sq` type representing the square on the board from which the piece is to be retrieved.
- **Control Flow**:
    - The function calls [`sqGetIndex`](square.c.md#sqGetIndex) with the square `s` to get the index of the square in the board's piece array.
    - It then accesses the `pieces` array of the board `b` using the calculated index to retrieve the piece located at that square.
- **Output**: The function returns a `piece` type, which is the chess piece located at the specified square on the board.
- **Functions called**:
    - [`sqGetIndex`](square.c.md#sqGetIndex)


---
### boardGenerateMoves<!-- {{#callable:boardGenerateMoves}} -->
The `boardGenerateMoves` function generates a list of all legal moves for the current player on a given chess board, including castling moves, and returns this list.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess board.
- **Control Flow**:
    - Create an empty move list using [`moveListCreate`](movelist.c.md#moveListCreate).
    - Iterate over each square on the board (64 squares total).
    - For each square, retrieve the piece and check if it belongs to the current player; if not, continue to the next square.
    - Determine the type of piece and generate potential moves for that piece using the appropriate function (e.g., [`pmGetPawnMoves`](piecemoves.c.md#pmGetPawnMoves) for pawns).
    - For each potential move, simulate the move on a copy of the board and check if it results in the current player being in check; if not, add the move to the move list.
    - Free the list of potential moves after processing.
    - Check if castling is possible for the current player by verifying the castling state and ensuring the path is clear and not under attack.
    - Add valid castling moves to the move list if conditions are met.
    - Return the list of legal moves.
- **Output**: A pointer to a `moveList` structure containing all legal moves for the current player, which must be freed after use.
- **Functions called**:
    - [`moveListCreate`](movelist.c.md#moveListCreate)
    - [`sqIndex`](square.c.md#sqIndex)
    - [`boardGetPiece`](#boardGetPiece)
    - [`pieceGetColor`](piece.c.md#pieceGetColor)
    - [`pieceGetType`](piece.c.md#pieceGetType)
    - [`pmGetPawnMoves`](piecemoves.c.md#pmGetPawnMoves)
    - [`pmGetKnightMoves`](piecemoves.c.md#pmGetKnightMoves)
    - [`pmGetBishopMoves`](piecemoves.c.md#pmGetBishopMoves)
    - [`pmGetRookMoves`](piecemoves.c.md#pmGetRookMoves)
    - [`pmGetQueenMoves`](piecemoves.c.md#pmGetQueenMoves)
    - [`pmGetKingMoves`](piecemoves.c.md#pmGetKingMoves)
    - [`boardPlayMoveInPlace`](#boardPlayMoveInPlace)
    - [`boardIsPlayerInCheck`](#boardIsPlayerInCheck)
    - [`moveListAdd`](movelist.c.md#moveListAdd)
    - [`moveListFree`](movelist.c.md#moveListFree)
    - [`sqI`](square.c.md#sqI)
    - [`boardIsSquareAttacked`](#boardIsSquareAttacked)
    - [`moveSq`](move.c.md#moveSq)


---
### boardIsSquareAttacked<!-- {{#callable:boardIsSquareAttacked}} -->
The function `boardIsSquareAttacked` checks if a specific square on a chess board is attacked by any piece of a given color.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chess board.
    - `s`: The square (`sq` type) on the board to check for attacks.
    - `attacker`: The color of the pieces (`pieceColor` type) that are considered as potential attackers.
- **Control Flow**:
    - Iterate over all 64 squares on the board.
    - For each square, retrieve the piece located there and check if it matches the attacker's color.
    - If the piece matches the attacker's color, determine its type and generate a list of possible moves or attacks for that piece type.
    - Iterate through the generated move list to check if any move targets the specified square `s`.
    - If a move targets the square `s`, set a flag indicating the square is attacked and break out of the loop.
    - Free the move list memory after checking.
    - Return 1 if the square is attacked, otherwise continue checking other pieces.
    - Return 0 if no attacking piece is found after checking all squares.
- **Output**: Returns `1` if the square `s` is attacked by any piece of the specified color, otherwise returns `0`.
- **Functions called**:
    - [`sqIndex`](square.c.md#sqIndex)
    - [`boardGetPiece`](#boardGetPiece)
    - [`pieceGetColor`](piece.c.md#pieceGetColor)
    - [`pieceGetType`](piece.c.md#pieceGetType)
    - [`pmGetPawnAttacks`](piecemoves.c.md#pmGetPawnAttacks)
    - [`pmGetKnightMoves`](piecemoves.c.md#pmGetKnightMoves)
    - [`pmGetBishopMoves`](piecemoves.c.md#pmGetBishopMoves)
    - [`pmGetRookMoves`](piecemoves.c.md#pmGetRookMoves)
    - [`pmGetQueenMoves`](piecemoves.c.md#pmGetQueenMoves)
    - [`pmGetKingMoves`](piecemoves.c.md#pmGetKingMoves)
    - [`sqEq`](square.c.md#sqEq)
    - [`moveListFree`](movelist.c.md#moveListFree)


---
### boardIsInCheck<!-- {{#callable:boardIsInCheck}} -->
The `boardIsInCheck` function checks if the current player on a given chess board is in check.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess game.
- **Control Flow**:
    - The function calls [`boardIsPlayerInCheck`](#boardIsPlayerInCheck), passing the board and the current player as arguments.
    - It returns the result of the [`boardIsPlayerInCheck`](#boardIsPlayerInCheck) function, which determines if the current player's king is under attack.
- **Output**: A `uint8_t` value indicating whether the current player is in check (1 if in check, 0 otherwise).
- **Functions called**:
    - [`boardIsPlayerInCheck`](#boardIsPlayerInCheck)


---
### boardIsPlayerInCheck<!-- {{#callable:boardIsPlayerInCheck}} -->
The function `boardIsPlayerInCheck` checks if a player's king is in check on a given chess board.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess board.
    - `player`: A `pieceColor` value indicating the color of the player (either `pcWhite` or `pcBlack`) whose king's check status is being evaluated.
- **Control Flow**:
    - Determine the type of the player's king (`pWKing` for white, `pBKing` for black) and the opponent's color.
    - Iterate over all 64 squares of the board to find the player's king.
    - For each square, check if it contains the player's king.
    - If the king is found, check if the square is attacked by any piece of the opponent's color using [`boardIsSquareAttacked`](#boardIsSquareAttacked).
    - If the square is attacked, return 1 indicating the king is in check.
    - If no attack is found on the king's square after checking all squares, return 0 indicating the king is not in check.
- **Output**: Returns `1` if the player's king is in check, otherwise returns `0`.
- **Functions called**:
    - [`sqIndex`](square.c.md#sqIndex)
    - [`boardGetPiece`](#boardGetPiece)
    - [`boardIsSquareAttacked`](#boardIsSquareAttacked)


---
### boardIsInsufficientMaterial<!-- {{#callable:boardIsInsufficientMaterial}} -->
The function `boardIsInsufficientMaterial` checks if a chess board position is a draw due to insufficient material to checkmate.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess board.
- **Control Flow**:
    - Initialize counters for pieces, knights, bishops on dark squares, bishops on light squares, and kings.
    - Iterate over all 64 squares of the board to count the number of each type of piece.
    - Check if the board only has kings, which is always a draw, and return 1 if true.
    - Check if there is one white king and one black king, and if the total number of pieces equals the sum of kings, knights, and bishops.
    - If there are only two kings and one minor piece (knight or bishop), return 1 indicating a draw.
    - If there are only two kings and bishops all on the same color, return 1 indicating a draw.
    - Return 0 if none of the conditions for insufficient material are met.
- **Output**: Returns 1 if the board position is a draw due to insufficient material, otherwise returns 0.
- **Functions called**:
    - [`sqIndex`](square.c.md#sqIndex)
    - [`boardGetPiece`](#boardGetPiece)
    - [`pieceGetType`](piece.c.md#pieceGetType)
    - [`sqIsDark`](square.c.md#sqIsDark)


---
### boardPlayMove<!-- {{#callable:boardPlayMove}} -->
The `boardPlayMove` function creates a new chess board state by applying a given move to an existing board.
- **Inputs**:
    - `b`: A pointer to the current board state represented by a `board` structure.
    - `m`: A `move` structure representing the move to be applied to the board.
- **Control Flow**:
    - Allocate memory for a new `board` structure and assign it to `newBoard`.
    - Copy the contents of the existing board `b` into `newBoard` using `memcpy`.
    - Call [`boardPlayMoveInPlace`](#boardPlayMoveInPlace) to apply the move `m` to `newBoard` in place.
    - Return the pointer to the newly created `newBoard` with the move applied.
- **Output**: A pointer to a new `board` structure that represents the board state after the move `m` has been applied.
- **Functions called**:
    - [`boardPlayMoveInPlace`](#boardPlayMoveInPlace)


---
### boardPlayMoveInPlace<!-- {{#callable:boardPlayMoveInPlace}} -->
The `boardPlayMoveInPlace` function executes a given chess move on a board, updating the board's state accordingly, including handling special moves like castling and en passant.
- **Inputs**:
    - `b`: A pointer to the `board` structure representing the current state of the chess board.
    - `m`: A `move` structure representing the move to be played, including the starting and ending positions and any promotion details.
- **Control Flow**:
    - If the current player is black, increment the move number.
    - Determine if the move is irreversible (pawn move or capture) and reset or increment the half-move clock accordingly.
    - Check if the move is a castling move and update the board by moving the rook and clearing the castling rights.
    - If a rook moves or is captured, update the castling rights accordingly.
    - Handle en passant captures by removing the captured pawn from the board.
    - Move the piece from the source to the destination square, handling promotions if applicable.
    - Set the en passant target square if a pawn moves two squares forward, otherwise invalidate it.
    - Switch the current player to the other player.
- **Output**: The function does not return a value; it modifies the board in place to reflect the move played.
- **Functions called**:
    - [`pieceGetType`](piece.c.md#pieceGetType)
    - [`boardGetPiece`](#boardGetPiece)
    - [`boardSetPiece`](#boardSetPiece)
    - [`sqI`](square.c.md#sqI)
    - [`sqEq`](square.c.md#sqEq)
    - [`pieceMake`](piece.c.md#pieceMake)


---
### boardEq<!-- {{#callable:boardEq}} -->
The `boardEq` function checks if two chess board states are fully equal by comparing various attributes and the board's memory.
- **Inputs**:
    - `b1`: A pointer to the first board structure to be compared.
    - `b2`: A pointer to the second board structure to be compared.
- **Control Flow**:
    - Check if the current player of both boards is the same; if not, return 0.
    - Check if the castling state of both boards is the same; if not, return 0.
    - Check if the en passant target squares of both boards are equal using [`sqEq`](square.c.md#sqEq); if not, return 0.
    - Check if the half-move clock values of both boards are the same; if not, return 0.
    - Check if the move numbers of both boards are the same; if not, return 0.
    - Use `memcmp` to compare the memory of both boards for the first 64 pieces; if they differ, return 0.
    - If all checks pass, return 1 indicating the boards are fully equal.
- **Output**: Returns 1 if the boards are fully equal, otherwise returns 0.
- **Functions called**:
    - [`sqEq`](square.c.md#sqEq)


---
### boardEqContext<!-- {{#callable:boardEqContext}} -->
The `boardEqContext` function checks if two chess boards are contextually equal, ignoring move counters and filtering en passant target squares.
- **Inputs**:
    - `b1`: A pointer to the first board structure to compare.
    - `b2`: A pointer to the second board structure to compare.
- **Control Flow**:
    - Check if the current player on both boards is the same; if not, return 0.
    - Check if the castling state on both boards is the same; if not, return 0.
    - Compare the memory of the two boards for the first 64 pieces; if they differ, return 0.
    - Filter the en passant target square for board b1 by checking if any pawns can attack it; if not, set it to SQ_INVALID.
    - Filter the en passant target square for board b2 by checking if any pawns can attack it; if not, set it to SQ_INVALID.
    - Compare the filtered en passant target squares of both boards; if they differ, return 0.
    - If all checks pass, return 1 indicating the boards are contextually equal.
- **Output**: Returns 1 if the boards are contextually equal, otherwise returns 0.
- **Functions called**:
    - [`sqEq`](square.c.md#sqEq)
    - [`sqI`](square.c.md#sqI)
    - [`boardGetPiece`](#boardGetPiece)
    - [`boardPlayMoveInPlace`](#boardPlayMoveInPlace)
    - [`moveSq`](move.c.md#moveSq)
    - [`boardIsPlayerInCheck`](#boardIsPlayerInCheck)


---
### boardGetFen<!-- {{#callable:boardGetFen}} -->
The `boardGetFen` function generates a FEN (Forsyth-Edwards Notation) string representing the current state of a chess board.
- **Inputs**:
    - `b`: A pointer to a `board` structure representing the current state of the chess game.
- **Control Flow**:
    - Initialize a buffer `buf` to store the FEN string and a pointer `c` to traverse the buffer.
    - Iterate over each rank from 8 to 1 and each file from 1 to 8 to encode the piece positions on the board.
    - For each square, check if it contains a piece; if so, append the piece's letter to the buffer, otherwise count consecutive empty squares and append the count when a piece is encountered or the rank ends.
    - After processing each rank, append a '/' to separate ranks, except after the last rank.
    - Append the current player's turn ('w' for white, 'b' for black) to the buffer.
    - Encode the castling availability by checking the `castleState` and appending 'K', 'Q', 'k', 'q' as applicable, or '-' if no castling is available.
    - Encode the en passant target square by checking `epTarget` and appending its string representation or '-' if invalid.
    - Use `sprintf` to append the half-move clock and full move number to the buffer.
    - Allocate memory for the final FEN string, copy the buffer content into it, and return the allocated string.
- **Output**: A dynamically allocated string containing the FEN representation of the board, which must be freed by the caller.
- **Functions called**:
    - [`sqI`](square.c.md#sqI)
    - [`boardGetPiece`](#boardGetPiece)
    - [`pieceGetLetter`](piece.c.md#pieceGetLetter)
    - [`sqEq`](square.c.md#sqEq)
    - [`sqGetStr`](square.c.md#sqGetStr)



---
Made with ❤️ by [Driver](https://www.driver.ai/)