<!--------------------------------------------------------------------------------->
<!-- IMPORTANT: This file is auto-generated by Driver (https://driver.ai). -------->
<!-- Manual edits may be overwritten on future commits. --------------------------->
<!--------------------------------------------------------------------------------->

The `square.c` file in the `c_cpp_export_test` codebase provides functions for creating and manipulating chessboard squares, including conversion between different representations and checking square properties.

# Purpose
This C source code file provides functionality for handling chessboard squares, encapsulating operations related to the representation and manipulation of squares on a chessboard. The code defines several functions that allow for the creation and manipulation of square objects, which are represented by a custom data type `sq`. The primary operations include creating a square from file and rank integers ([`sqI`](#sqI)), from a Standard Algebraic Notation (SAN) string ([`sqS`](#sqS)), and from an index ([`sqIndex`](#sqIndex)). Additionally, the code provides utility functions to retrieve the index of a square ([`sqGetIndex`](#sqGetIndex)), convert a square to its SAN string representation ([`sqGetStr`](#sqGetStr)), determine if a square is dark or light ([`sqIsDark`](#sqIsDark)), and compare two squares for equality ([`sqEq`](#sqEq)).

The file is part of a larger library, as indicated by the inclusion of the header file "chesslib/square.h", suggesting that it is intended to be used as part of a chess-related software system. The code does not define a public API directly but provides essential internal functions that likely support higher-level operations within the library. The use of constants and checks ensures that the operations are constrained within the valid range of a standard 8x8 chessboard, enhancing the robustness of the library. The array `SQ_STRS` provides a mapping of indices to SAN strings, facilitating conversions between different square representations.
# Imports and Dependencies

---
- `chesslib/square.h`


# Global Variables

---
### SQ\_STRS
- **Type**: `const char*[]`
- **Description**: `SQ_STRS` is a global constant array of strings, where each string represents a square on a chessboard using standard algebraic notation (SAN). The array contains 64 elements, corresponding to the 64 squares on a chessboard, with each element being a string like "a1", "b1", etc., representing the file and rank of the square.
- **Use**: This array is used to map indices to their corresponding SAN strings for chessboard squares.


# Functions

---
### sqI<!-- {{#callable:sqI}} -->
The `sqI` function creates a chessboard square from given file and rank values, ensuring they are within valid bounds.
- **Inputs**:
    - `file`: An unsigned 8-bit integer representing the file (column) of the chessboard square, expected to be between 1 and 8.
    - `rank`: An unsigned 8-bit integer representing the rank (row) of the chessboard square, expected to be between 1 and 8.
- **Control Flow**:
    - Check if the file is less than 1 or greater than 8, or if the rank is less than 1 or greater than 8.
    - If any of the above conditions are true, return `SQ_INVALID`.
    - If the file and rank are within valid bounds, create a `sq` structure.
    - Assign the file and rank values to the `sq` structure's `file` and `rank` fields, respectively.
    - Return the `sq` structure.
- **Output**: A `sq` structure representing the chessboard square with the specified file and rank, or `SQ_INVALID` if the inputs are out of bounds.


---
### sqS<!-- {{#callable:sqS}} -->
The function `sqS` converts a string representing a chessboard square in SAN format to a `sq` structure with file and rank values.
- **Inputs**:
    - `str`: A pointer to a constant character string representing a chessboard square in SAN format, such as "e4".
- **Control Flow**:
    - Extract the first character `c1` from the input string `str`.
    - Check if `c1` is a valid file character (between 'a' and 'h'); if not, return `SQ_INVALID`.
    - Extract the second character `c2` from the input string `str`.
    - Check if `c2` is a valid rank character (between '1' and '8'); if not, return `SQ_INVALID`.
    - Create a `sq` structure `s` and set its `file` field to the numeric value corresponding to `c1` (1 for 'a', 2 for 'b', etc.).
    - Set the `rank` field of `s` to the numeric value of `c2`.
    - Return the `sq` structure `s`.
- **Output**: A `sq` structure representing the chessboard square with file and rank values, or `SQ_INVALID` if the input string is not a valid SAN square.


---
### sqIndex<!-- {{#callable:sqIndex}} -->
The `sqIndex` function converts an index into a chessboard square using a predefined string array.
- **Inputs**:
    - `index`: An unsigned 8-bit integer representing the index of the square, expected to be between 0 and 63 inclusive.
- **Control Flow**:
    - Check if the input index is less than 0 or greater than 63.
    - If the index is out of bounds, return `SQ_INVALID`.
    - If the index is valid, use it to access the `SQ_STRS` array to get the corresponding square string.
    - Call the [`sqS`](#sqS) function with the retrieved string to convert it into a `sq` type and return it.
- **Output**: Returns a `sq` type representing the chessboard square corresponding to the given index, or `SQ_INVALID` if the index is out of bounds.
- **Functions called**:
    - [`sqS`](#sqS)


---
### sqGetIndex<!-- {{#callable:sqGetIndex}} -->
The function `sqGetIndex` calculates the zero-based index of a chessboard square given its file and rank.
- **Inputs**:
    - `s`: A structure representing a square on a chessboard, containing two fields: `file` and `rank`, both of which are integers.
- **Control Flow**:
    - Check if the `file` or `rank` of the square `s` is outside the valid range (1 to 8); if so, return -1 indicating an invalid square.
    - Calculate the index using the formula `(8 * (s.rank - 1)) + (s.file - 1)` which converts the 2D file and rank into a 1D index.
- **Output**: Returns a `uint8_t` representing the zero-based index of the square on a chessboard, or -1 if the square is invalid.


---
### sqGetStr<!-- {{#callable:sqGetStr}} -->
The function `sqGetStr` returns the Standard Algebraic Notation (SAN) string representation of a given chess square.
- **Inputs**:
    - `s`: A chess square represented by the custom type `sq`, which contains file and rank information.
- **Control Flow**:
    - Call the helper function [`sqGetIndex`](#sqGetIndex) with the input square `s` to get its index.
    - Check if the index is greater than 63, which indicates an invalid square, and return the string '##' if true.
    - If the index is valid (0 to 63), return the corresponding SAN string from the `SQ_STRS` array.
- **Output**: A constant character pointer to the SAN string representing the square, or '##' if the square is invalid.
- **Functions called**:
    - [`sqGetIndex`](#sqGetIndex)


---
### sqIsDark<!-- {{#callable:sqIsDark}} -->
The function `sqIsDark` determines if a given chessboard square is dark-colored based on its rank and file.
- **Inputs**:
    - `s`: A `sq` structure representing a square on a chessboard, containing `rank` and `file` fields.
- **Control Flow**:
    - The function uses bitwise AND to check the least significant bit of both the `rank` and `file` fields of the square `s`.
    - It performs an XOR operation on these bits to determine if they are different.
    - The result of the XOR operation is negated to return 1 if the square is dark and 0 if it is light.
- **Output**: Returns 1 if the square is dark-colored, otherwise returns 0.


---
### sqEq<!-- {{#callable:sqEq}} -->
The `sqEq` function checks if two chessboard squares are equal by comparing their file and rank values, after validating their boundaries.
- **Inputs**:
    - `s1`: The first square to be compared, represented by a structure with file and rank attributes.
    - `s2`: The second square to be compared, also represented by a structure with file and rank attributes.
- **Control Flow**:
    - Check if the file or rank of the first square `s1` is out of the valid range (1 to 8); if so, set `s1` to `SQ_INVALID`.
    - Check if the file or rank of the second square `s2` is out of the valid range (1 to 8); if so, set `s2` to `SQ_INVALID`.
    - Compare the file and rank of `s1` and `s2` to determine if they are equal.
- **Output**: Returns 1 (true) if both squares have the same file and rank values, otherwise returns 0 (false).



---
Made with ❤️ by [Driver](https://www.driver.ai/)